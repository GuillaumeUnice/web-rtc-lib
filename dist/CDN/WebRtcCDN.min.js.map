{"version":3,"sources":["webpack:///WebRtcCDN.min.js","webpack:///webpack/bootstrap c4909757bf8bab59f262","webpack:///./src/WebRTCLib.ts","webpack:///./src/index.ts","webpack:///./~/ws-jms-lib-echyzen/dist/WsJMSLib.js","webpack:///./~/ws-jms-lib-echyzen/dist/index.js"],"names":["WebRtcCDN","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ws_jms_lib_echyzen_1","WebRTCLib","url","channelID","userID","_this","this","listTempRemoteIceCandidate","myRTCPeerConnection","getBrowserRTCConnectionObj","wsJmsLib","connect","subscribe","dispatchMessage","prototype","message","JSON","parse","console","log","type","user_id","setRemoteDescription","RTCSessionDescription","createAnswer","myDesc","getDescription","err","error","push","forEach","remoteIceCandidate","addIceCandidate","RTCIceCandidate","responseWebRTC","remoteDesc","servers","constraints","optional","window","mozRTCPeerConnection","webkitRTCPeerConnection","RTCPeerConnection","buildMessage","chatroom_id","sendIceCandidates","myRTCIceCandidateEvent","lightRTCIceCandidateEvent","candidate","sdpMid","sdpMLineIndex","send","stringify","setLocalDescription","createStream","userMediaStream","getLocalStream","getRemoteStream","navigator","getUserMedia","myStream","addStream","onicecandidate","onaddstream","evt","stream","createOffer","attachStream","mediaStream","HTMLElement","attachMediaStream","WebRTCLib_1","connection","session","consumers","createDestination","name","reTopic","RegExp","baseTopicUrl","reQueue","baseQueueUrl","match","createTopic","createQueue","Error","textMessage","createTextMessage","callback","connectionFactory","JmsConnectionFactory","that","connectionFuture","createConnection","getValue","createSession","Session","AUTO_ACKNOWLEDGE","start","channelName","messageListener","context","topic","consumer","createConsumer","setMessageListener","getText","dest","producer","createProducer","future_1","exception","e","close","unsubscribe","WsJMSLib_1"],"mappings":"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","file":"WebRtcCDN.min.js","sourcesContent":["var WebRtcCDN =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ws_jms_lib_echyzen_1 = __webpack_require__(4);\n\t// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\t// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// } , function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// });\n\t// class ConfigWebRTC {\n\t//   constructor(public url: string, public channelID: string, public userID: string) { };\n\t//   static RESPONSE = \"response_web_rtc\";\n\t//   static REQUEST = \"request_web_rtc\"; \n\t//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n\t// }\n\t//\"ws-jms-lib-echyzen\": \"0.0.17\"\n\tvar WebRTCLib = (function () {\n\t    function WebRTCLib(url, channelID, userID) {\n\t        var _this = this;\n\t        this.url = url;\n\t        this.channelID = channelID;\n\t        this.userID = userID;\n\t        this.listTempRemoteIceCandidate = [];\n\t        this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n\t        this.wsJmsLib = new ws_jms_lib_echyzen_1.wsJmsLib();\n\t        this.wsJmsLib.connect(url, function () {\n\t            _this.wsJmsLib.subscribe(channelID, _this.dispatchMessage, _this);\n\t        });\n\t    }\n\t    WebRTCLib.prototype.dispatchMessage = function (message) {\n\t        var _this = this;\n\t        message = JSON.parse(message);\n\t        console.log('dispatchMessage', message);\n\t        switch (message.type) {\n\t            case 'request_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('request_web_rtc', message);\n\t                    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(message.message), function () {\n\t                        _this.myRTCPeerConnection.createAnswer(function (myDesc) {\n\t                            _this.getDescription(myDesc);\n\t                        }, function (err) { return console.error(err); });\n\t                    }, function (err) { return console.error(err); });\n\t                }\n\t                break;\n\t            case 'ice_candidate_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('ice_candidate_web_rtc', message);\n\t                    if (message.message) {\n\t                        this.listTempRemoteIceCandidate.push(message.message);\n\t                    }\n\t                    else {\n\t                        this.listTempRemoteIceCandidate.forEach(function (remoteIceCandidate) {\n\t                            _this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n\t                        });\n\t                    }\n\t                }\n\t                break;\n\t            case 'response_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('response_web_rtc', message);\n\t                    this.responseWebRTC(message.message);\n\t                }\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t    };\n\t    WebRTCLib.prototype.responseWebRTC = function (remoteDesc) {\n\t        this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n\t    };\n\t    WebRTCLib.prototype.getBrowserRTCConnectionObj = function () {\n\t        var servers = null;\n\t        var constraints = {\n\t            'optional': []\n\t        };\n\t        if (window.mozRTCPeerConnection) {\n\t            return new mozRTCPeerConnection(servers, constraints);\n\t        }\n\t        else if (window.webkitRTCPeerConnection) {\n\t            return new webkitRTCPeerConnection(servers, constraints);\n\t        }\n\t        else {\n\t            return new RTCPeerConnection(servers, constraints);\n\t        }\n\t    };\n\t    WebRTCLib.prototype.buildMessage = function (message, type) {\n\t        return {\n\t            chatroom_id: this.channelID,\n\t            user_id: this.userID,\n\t            type: type,\n\t            message: message\n\t        };\n\t    };\n\t    WebRTCLib.prototype.sendIceCandidates = function (myRTCIceCandidateEvent) {\n\t        var lightRTCIceCandidateEvent = null;\n\t        if (myRTCIceCandidateEvent.candidate) {\n\t            lightRTCIceCandidateEvent = {\n\t                sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n\t                sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n\t                candidate: myRTCIceCandidateEvent.candidate.candidate\n\t            };\n\t        }\n\t        var message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n\t        this.wsJmsLib.send(JSON.stringify(message), this.channelID, function () { });\n\t    };\n\t    WebRTCLib.prototype.getDescription = function (myDesc) {\n\t        var _this = this;\n\t        this.myRTCPeerConnection.setLocalDescription(myDesc, function () {\n\t            var message = _this.buildMessage(myDesc, 'response_web_rtc');\n\t            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t        });\n\t    };\n\t    ////////////////////////////////////////////////////////////////\n\t    WebRTCLib.prototype.createStream = function (userMediaStream, getLocalStream, getRemoteStream) {\n\t        var _this = this;\n\t        navigator.getUserMedia(userMediaStream, function (myStream) {\n\t            _this.myRTCPeerConnection.addStream(myStream);\n\t            getLocalStream(myStream);\n\t            _this.myRTCPeerConnection.onicecandidate = function (myRTCIceCandidateEvent) {\n\t                _this.sendIceCandidates(myRTCIceCandidateEvent);\n\t            };\n\t            _this.myRTCPeerConnection.onaddstream = function (evt) {\n\t                getRemoteStream(evt.stream);\n\t            };\n\t        }, function (err) { return console.error(err); });\n\t    };\n\t    WebRTCLib.prototype.createOffer = function () {\n\t        var _this = this;\n\t        this.myRTCPeerConnection.createOffer(function (myDesc) {\n\t            _this.myRTCPeerConnection.setLocalDescription(myDesc);\n\t            var message = _this.buildMessage(myDesc, 'request_web_rtc');\n\t            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t        }, function (err) { console.error(err); });\n\t    };\n\t    WebRTCLib.attachStream = function (mediaStream, HTMLElement) {\n\t        HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n\t    };\n\t    return WebRTCLib;\n\t}());\n\texports.WebRTCLib = WebRTCLib;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../typings/index.d.ts\" />\n\t/// <reference path=\"./Temasys.d.ts\" />\n\t\"use strict\";\n\tvar WebRTCLib_1 = __webpack_require__(1);\n\texports.WebRTCLib = WebRTCLib_1.WebRTCLib;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\t\"use strict\";\n\tvar wsJmsLib = (function () {\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    function wsJmsLib() {\n\t        this.connection = {};\n\t        this.session = {};\n\t        this.consumers = {};\n\t    }\n\t    wsJmsLib.prototype.createDestination = function (name) {\n\t        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n\t        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n\t        if (name.match(reTopic)) {\n\t            return this.session.createTopic(name);\n\t        }\n\t        else if (name.match(reQueue)) {\n\t            return this.session.createQueue(name);\n\t        }\n\t        else {\n\t            throw new Error(\"Destination must start with /topic/ or /queue/\");\n\t        }\n\t    };\n\t    wsJmsLib.prototype.buildMessage = function (message) {\n\t        var textMessage = this.session.createTextMessage(message);\n\t        return textMessage;\n\t    };\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    wsJmsLib.prototype.connect = function (url, callback) {\n\t        var connectionFactory = new JmsConnectionFactory(url);\n\t        var that = this;\n\t        var connectionFuture = connectionFactory.createConnection(function () {\n\t            try {\n\t                that.connection = connectionFuture.getValue();\n\t            }\n\t            catch (err) {\n\t                console.error(err);\n\t            }\n\t            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t            that.connection.start(function () {\n\t                callback();\n\t            });\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.subscribe = function (channelName, messageListener, context) {\n\t        // assuming connection has already been established and started\n\t        // ideally we need to maintain the state of the connection and throw error\n\t        // if the controller calls subscribe before connection is established\n\t        // or after the connection is closed\n\t        var topic = this.session.createTopic(channelName);\n\t        var consumer = this.session.createConsumer(topic);\n\t        this.consumers[channelName] = consumer;\n\t        consumer.setMessageListener(function (message) {\n\t            messageListener.call(context, message.getText());\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.send = function (message, topic, callback) {\n\t        var dest = this.createDestination(topic);\n\t        var producer = this.session.createProducer(dest);\n\t        var textMessage = this.buildMessage(message);\n\t        try {\n\t            var future_1 = producer.send(textMessage, function () {\n\t                if (future_1.exception) {\n\t                    console.error(future_1.exception);\n\t                }\n\t                callback();\n\t            });\n\t        }\n\t        catch (e) {\n\t            console.error(e);\n\t        }\n\t        producer.close();\n\t    };\n\t    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n\t        var consumer = this.consumers[channelName];\n\t        if (consumer) {\n\t            delete this.consumers[channelName];\n\t            consumer.close(callback);\n\t        }\n\t    };\n\t    ;\n\t    wsJmsLib.baseTopicUrl = 'topic';\n\t    wsJmsLib.baseQueueUrl = 'queue';\n\t    return wsJmsLib;\n\t}());\n\texports.wsJmsLib = wsJmsLib;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WsJMSLib_1 = __webpack_require__(3);\n\texports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// WebRtcCDN.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c4909757bf8bab59f262","\"use strict\";\nvar ws_jms_lib_echyzen_1 = require('ws-jms-lib-echyzen');\n// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// } , function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// });\n// class ConfigWebRTC {\n//   constructor(public url: string, public channelID: string, public userID: string) { };\n//   static RESPONSE = \"response_web_rtc\";\n//   static REQUEST = \"request_web_rtc\"; \n//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n// }\n//\"ws-jms-lib-echyzen\": \"0.0.17\"\nvar WebRTCLib = (function () {\n    function WebRTCLib(url, channelID, userID) {\n        var _this = this;\n        this.url = url;\n        this.channelID = channelID;\n        this.userID = userID;\n        this.listTempRemoteIceCandidate = [];\n        this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n        this.wsJmsLib = new ws_jms_lib_echyzen_1.wsJmsLib();\n        this.wsJmsLib.connect(url, function () {\n            _this.wsJmsLib.subscribe(channelID, _this.dispatchMessage, _this);\n        });\n    }\n    WebRTCLib.prototype.dispatchMessage = function (message) {\n        var _this = this;\n        message = JSON.parse(message);\n        console.log('dispatchMessage', message);\n        switch (message.type) {\n            case 'request_web_rtc':\n                if (this.userID !== message.user_id) {\n                    console.log('request_web_rtc', message);\n                    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(message.message), function () {\n                        _this.myRTCPeerConnection.createAnswer(function (myDesc) {\n                            _this.getDescription(myDesc);\n                        }, function (err) { return console.error(err); });\n                    }, function (err) { return console.error(err); });\n                }\n                break;\n            case 'ice_candidate_web_rtc':\n                if (this.userID !== message.user_id) {\n                    console.log('ice_candidate_web_rtc', message);\n                    if (message.message) {\n                        this.listTempRemoteIceCandidate.push(message.message);\n                    }\n                    else {\n                        this.listTempRemoteIceCandidate.forEach(function (remoteIceCandidate) {\n                            _this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n                        });\n                    }\n                }\n                break;\n            case 'response_web_rtc':\n                if (this.userID !== message.user_id) {\n                    console.log('response_web_rtc', message);\n                    this.responseWebRTC(message.message);\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    WebRTCLib.prototype.responseWebRTC = function (remoteDesc) {\n        this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n    };\n    WebRTCLib.prototype.getBrowserRTCConnectionObj = function () {\n        var servers = null;\n        var constraints = {\n            'optional': []\n        };\n        if (window.mozRTCPeerConnection) {\n            return new mozRTCPeerConnection(servers, constraints);\n        }\n        else if (window.webkitRTCPeerConnection) {\n            return new webkitRTCPeerConnection(servers, constraints);\n        }\n        else {\n            return new RTCPeerConnection(servers, constraints);\n        }\n    };\n    WebRTCLib.prototype.buildMessage = function (message, type) {\n        return {\n            chatroom_id: this.channelID,\n            user_id: this.userID,\n            type: type,\n            message: message\n        };\n    };\n    WebRTCLib.prototype.sendIceCandidates = function (myRTCIceCandidateEvent) {\n        var lightRTCIceCandidateEvent = null;\n        if (myRTCIceCandidateEvent.candidate) {\n            lightRTCIceCandidateEvent = {\n                sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n                sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n                candidate: myRTCIceCandidateEvent.candidate.candidate\n            };\n        }\n        var message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n        this.wsJmsLib.send(JSON.stringify(message), this.channelID, function () { });\n    };\n    WebRTCLib.prototype.getDescription = function (myDesc) {\n        var _this = this;\n        this.myRTCPeerConnection.setLocalDescription(myDesc, function () {\n            var message = _this.buildMessage(myDesc, 'response_web_rtc');\n            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n        });\n    };\n    ////////////////////////////////////////////////////////////////\n    WebRTCLib.prototype.createStream = function (userMediaStream, getLocalStream, getRemoteStream) {\n        var _this = this;\n        navigator.getUserMedia(userMediaStream, function (myStream) {\n            _this.myRTCPeerConnection.addStream(myStream);\n            getLocalStream(myStream);\n            _this.myRTCPeerConnection.onicecandidate = function (myRTCIceCandidateEvent) {\n                _this.sendIceCandidates(myRTCIceCandidateEvent);\n            };\n            _this.myRTCPeerConnection.onaddstream = function (evt) {\n                getRemoteStream(evt.stream);\n            };\n        }, function (err) { return console.error(err); });\n    };\n    WebRTCLib.prototype.createOffer = function () {\n        var _this = this;\n        this.myRTCPeerConnection.createOffer(function (myDesc) {\n            _this.myRTCPeerConnection.setLocalDescription(myDesc);\n            var message = _this.buildMessage(myDesc, 'request_web_rtc');\n            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n        }, function (err) { console.error(err); });\n    };\n    WebRTCLib.attachStream = function (mediaStream, HTMLElement) {\n        HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n    };\n    return WebRTCLib;\n}());\nexports.WebRTCLib = WebRTCLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/WebRTCLib.ts\n// module id = 1\n// module chunks = 0","/// <reference path=\"../typings/index.d.ts\" />\n/// <reference path=\"./Temasys.d.ts\" />\n\"use strict\";\nvar WebRTCLib_1 = require('./WebRTCLib');\nexports.WebRTCLib = WebRTCLib_1.WebRTCLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 2\n// module chunks = 0","/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\"use strict\";\nvar wsJmsLib = (function () {\n    //////////////////////////////////////////////////////////////////////////////////\n    function wsJmsLib() {\n        this.connection = {};\n        this.session = {};\n        this.consumers = {};\n    }\n    wsJmsLib.prototype.createDestination = function (name) {\n        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n        if (name.match(reTopic)) {\n            return this.session.createTopic(name);\n        }\n        else if (name.match(reQueue)) {\n            return this.session.createQueue(name);\n        }\n        else {\n            throw new Error(\"Destination must start with /topic/ or /queue/\");\n        }\n    };\n    wsJmsLib.prototype.buildMessage = function (message) {\n        var textMessage = this.session.createTextMessage(message);\n        return textMessage;\n    };\n    //////////////////////////////////////////////////////////////////////////////////\n    wsJmsLib.prototype.connect = function (url, callback) {\n        var connectionFactory = new JmsConnectionFactory(url);\n        var that = this;\n        var connectionFuture = connectionFactory.createConnection(function () {\n            try {\n                that.connection = connectionFuture.getValue();\n            }\n            catch (err) {\n                console.error(err);\n            }\n            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            that.connection.start(function () {\n                callback();\n            });\n        });\n    };\n    ;\n    wsJmsLib.prototype.subscribe = function (channelName, messageListener, context) {\n        // assuming connection has already been established and started\n        // ideally we need to maintain the state of the connection and throw error\n        // if the controller calls subscribe before connection is established\n        // or after the connection is closed\n        var topic = this.session.createTopic(channelName);\n        var consumer = this.session.createConsumer(topic);\n        this.consumers[channelName] = consumer;\n        consumer.setMessageListener(function (message) {\n            messageListener.call(context, message.getText());\n        });\n    };\n    ;\n    wsJmsLib.prototype.send = function (message, topic, callback) {\n        var dest = this.createDestination(topic);\n        var producer = this.session.createProducer(dest);\n        var textMessage = this.buildMessage(message);\n        try {\n            var future_1 = producer.send(textMessage, function () {\n                if (future_1.exception) {\n                    console.error(future_1.exception);\n                }\n                callback();\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n        producer.close();\n    };\n    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n        var consumer = this.consumers[channelName];\n        if (consumer) {\n            delete this.consumers[channelName];\n            consumer.close(callback);\n        }\n    };\n    ;\n    wsJmsLib.baseTopicUrl = 'topic';\n    wsJmsLib.baseQueueUrl = 'queue';\n    return wsJmsLib;\n}());\nexports.wsJmsLib = wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/WsJMSLib.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar WsJMSLib_1 = require('./WsJMSLib');\nexports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}