{"version":3,"sources":["webpack:///WebRtcCDN.min.js","webpack:///webpack/bootstrap c891a4945bb3df7c2ea1","webpack:///./src/WebRTCLib.ts","webpack:///./src/index.ts","webpack:///./~/ws-jms-lib-echyzen/dist/WsJMSLib.js","webpack:///./~/ws-jms-lib-echyzen/dist/index.js"],"names":["WebRtcCDN","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ws_jms_lib_echyzen_1","WebRTCLib","url","channelID","userID","_this","this","myRTCPeerConnection","getBrowserRTCConnectionObj","wsJmsLib","connect","subscribe","dispatchMessage","prototype","message","JSON","parse","console","log","type","user_id","setRemoteDescription","RTCSessionDescription","tempRemoteDesc","createAnswer","getDescription","err","error","listTempRemoteIceCandidate","push","responseWebRTC","remoteDesc","servers","constraints","optional","window","mozRTCPeerConnection","webkitRTCPeerConnection","RTCPeerConnection","buildMessage","chatroom_id","sendIceCandidates","myRTCIceCandidateEvent","candidate","lightRTCIceCandidateEvent","sdpMid","sdpMLineIndex","send","stringify","myDesc","setLocalDescription","forEach","remoteIceCandidate","addIceCandidate","RTCIceCandidate","createStream","userMediaStream","getLocalStream","getRemoteStream","navigator","getUserMedia","myStream","addStream","onicecandidate","onaddstream","evt","stream","createOffer","attachStream","mediaStream","HTMLElement","attachMediaStream","WebRTCLib_1","connection","session","consumers","createDestination","name","reTopic","RegExp","baseTopicUrl","reQueue","baseQueueUrl","match","createTopic","createQueue","Error","textMessage","createTextMessage","callback","connectionFactory","JmsConnectionFactory","that","connectionFuture","createConnection","getValue","createSession","Session","AUTO_ACKNOWLEDGE","start","channelName","messageListener","topic","consumer","createConsumer","setMessageListener","getText","dest","producer","createProducer","future_1","exception","e","close","unsubscribe","WsJMSLib_1"],"mappings":"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","file":"WebRtcCDN.min.js","sourcesContent":["var WebRtcCDN =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ws_jms_lib_echyzen_1 = __webpack_require__(4);\n\t// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\t// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// } , function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// });\n\t// class ConfigWebRTC {\n\t//   constructor(public url: string, public channelID: string, public userID: string) { };\n\t//   static RESPONSE = \"response_web_rtc\";\n\t//   static REQUEST = \"request_web_rtc\"; \n\t//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n\t// }\n\t//\"ws-jms-lib-echyzen\": \"0.0.17\"\n\tvar WebRTCLib = (function () {\n\t    function WebRTCLib(url, channelID, userID) {\n\t        var _this = this;\n\t        this.url = url;\n\t        this.channelID = channelID;\n\t        this.userID = userID;\n\t        this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n\t        this.wsJmsLib = new ws_jms_lib_echyzen_1.wsJmsLib();\n\t        this.wsJmsLib.connect(url, function () {\n\t            _this.wsJmsLib.subscribe(channelID, _this.dispatchMessage);\n\t        });\n\t    }\n\t    WebRTCLib.prototype.dispatchMessage = function (message) {\n\t        var _this = this;\n\t        message = JSON.parse(message);\n\t        console.log('dispatchMessage', message);\n\t        switch (message.type) {\n\t            case 'request_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('request_web_rtc', message);\n\t                    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(this.tempRemoteDesc), function () {\n\t                        _this.myRTCPeerConnection.createAnswer(_this.getDescription, function (err) { return console.error(err); });\n\t                    }, function (err) { return console.error(err); });\n\t                    this.tempRemoteDesc = message;\n\t                }\n\t                break;\n\t            case 'ice_candidate_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('ice_candidate_web_rtc', message);\n\t                    this.listTempRemoteIceCandidate.push(message.message);\n\t                }\n\t                break;\n\t            case 'response_web_rtc':\n\t                if (this.userID !== message.user_id) {\n\t                    console.log('response_web_rtc', message);\n\t                    this.responseWebRTC(message.message);\n\t                }\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t    };\n\t    WebRTCLib.prototype.responseWebRTC = function (remoteDesc) {\n\t        this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n\t    };\n\t    WebRTCLib.prototype.getBrowserRTCConnectionObj = function () {\n\t        var servers = null;\n\t        var constraints = {\n\t            'optional': []\n\t        };\n\t        if (window.mozRTCPeerConnection) {\n\t            return new mozRTCPeerConnection(servers, constraints);\n\t        }\n\t        else if (window.webkitRTCPeerConnection) {\n\t            return new webkitRTCPeerConnection(servers, constraints);\n\t        }\n\t        else {\n\t            return new RTCPeerConnection(servers, constraints);\n\t        }\n\t    };\n\t    WebRTCLib.prototype.buildMessage = function (message, type) {\n\t        return {\n\t            chatroom_id: this.channelID,\n\t            user_id: this.userID,\n\t            type: type,\n\t            message: message\n\t        };\n\t    };\n\t    WebRTCLib.prototype.sendIceCandidates = function (myRTCIceCandidateEvent) {\n\t        if (myRTCIceCandidateEvent.candidate) {\n\t            var lightRTCIceCandidateEvent = {\n\t                sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n\t                sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n\t                candidate: myRTCIceCandidateEvent.candidate.candidate\n\t            };\n\t            var message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n\t            this.wsJmsLib.send(JSON.stringify(message), this.channelID, function () { });\n\t        }\n\t    };\n\t    WebRTCLib.prototype.getDescription = function (myDesc) {\n\t        var _this = this;\n\t        this.myRTCPeerConnection.setLocalDescription(myDesc, function () {\n\t            _this.listTempRemoteIceCandidate.forEach(function (remoteIceCandidate) {\n\t                _this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n\t            });\n\t            var message = _this.buildMessage(myDesc, 'response_web_rtc');\n\t            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t        });\n\t    };\n\t    ////////////////////////////////////////////////////////////////\n\t    WebRTCLib.prototype.createStream = function (userMediaStream, getLocalStream, getRemoteStream) {\n\t        var _this = this;\n\t        navigator.getUserMedia(userMediaStream, function (myStream) {\n\t            _this.myRTCPeerConnection.addStream(myStream);\n\t            getLocalStream(myStream);\n\t            _this.myRTCPeerConnection.onicecandidate = function (myRTCIceCandidateEvent) {\n\t                _this.sendIceCandidates(myRTCIceCandidateEvent);\n\t            };\n\t            _this.myRTCPeerConnection.onaddstream = function (evt) {\n\t                getRemoteStream(evt.stream);\n\t            };\n\t            // This condition determine if you are the WebRTC's receiver or not\n\t            if (_this.tempRemoteDesc) {\n\t            }\n\t            else {\n\t                _this.myRTCPeerConnection.createOffer(function (myDesc) {\n\t                    _this.myRTCPeerConnection.setLocalDescription(myDesc);\n\t                    var message = _this.buildMessage(myDesc, 'request_web_rtc');\n\t                    _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t                }, function (err) { console.error(err); });\n\t            }\n\t        }, function (err) { return console.error(err); });\n\t    };\n\t    WebRTCLib.attachStream = function (mediaStream, HTMLElement) {\n\t        HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n\t    };\n\t    return WebRTCLib;\n\t}());\n\texports.WebRTCLib = WebRTCLib;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../typings/index.d.ts\" />\n\t/// <reference path=\"./Temasys.d.ts\" />\n\t\"use strict\";\n\tvar WebRTCLib_1 = __webpack_require__(1);\n\texports.WebRTCLib = WebRTCLib_1.WebRTCLib;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\t\"use strict\";\n\tvar wsJmsLib = (function () {\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    function wsJmsLib() {\n\t        this.connection = {};\n\t        this.session = {};\n\t        this.consumers = {};\n\t    }\n\t    wsJmsLib.prototype.createDestination = function (name) {\n\t        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n\t        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n\t        if (name.match(reTopic)) {\n\t            return this.session.createTopic(name);\n\t        }\n\t        else if (name.match(reQueue)) {\n\t            return this.session.createQueue(name);\n\t        }\n\t        else {\n\t            throw new Error(\"Destination must start with /topic/ or /queue/\");\n\t        }\n\t    };\n\t    wsJmsLib.prototype.buildMessage = function (message) {\n\t        var textMessage = this.session.createTextMessage(message);\n\t        return textMessage;\n\t    };\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    wsJmsLib.prototype.connect = function (url, callback) {\n\t        var connectionFactory = new JmsConnectionFactory(url);\n\t        var that = this;\n\t        var connectionFuture = connectionFactory.createConnection(function () {\n\t            try {\n\t                that.connection = connectionFuture.getValue();\n\t            }\n\t            catch (err) {\n\t                console.error(err);\n\t            }\n\t            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t            that.connection.start(function () {\n\t                callback();\n\t            });\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.subscribe = function (channelName, messageListener) {\n\t        var _this = this;\n\t        // assuming connection has already been established and started\n\t        // ideally we need to maintain the state of the connection and throw error\n\t        // if the controller calls subscribe before connection is established\n\t        // or after the connection is closed\n\t        var topic = this.session.createTopic(channelName);\n\t        var consumer = this.session.createConsumer(topic);\n\t        this.consumers[channelName] = consumer;\n\t        consumer.setMessageListener(function (message) {\n\t            messageListener.call(_this, message.getText());\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.send = function (message, topic, callback) {\n\t        var dest = this.createDestination(topic);\n\t        var producer = this.session.createProducer(dest);\n\t        var textMessage = this.buildMessage(message);\n\t        try {\n\t            var future_1 = producer.send(textMessage, function () {\n\t                if (future_1.exception) {\n\t                    console.error(future_1.exception);\n\t                }\n\t                callback();\n\t            });\n\t        }\n\t        catch (e) {\n\t            console.error(e);\n\t        }\n\t        producer.close();\n\t    };\n\t    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n\t        var consumer = this.consumers[channelName];\n\t        if (consumer) {\n\t            delete this.consumers[channelName];\n\t            consumer.close(callback);\n\t        }\n\t    };\n\t    ;\n\t    wsJmsLib.baseTopicUrl = 'topic';\n\t    wsJmsLib.baseQueueUrl = 'queue';\n\t    return wsJmsLib;\n\t}());\n\texports.wsJmsLib = wsJmsLib;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar WsJMSLib_1 = __webpack_require__(3);\n\texports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// WebRtcCDN.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c891a4945bb3df7c2ea1","import {wsJmsLib} from 'ws-jms-lib-echyzen';\n\n// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\n// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// } , function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// });\n\n\n// class ConfigWebRTC {\n//   constructor(public url: string, public channelID: string, public userID: string) { };\n  \n//   static RESPONSE = \"response_web_rtc\";\n//   static REQUEST = \"request_web_rtc\"; \n//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n// }\n    //\"ws-jms-lib-echyzen\": \"0.0.17\"\n\nexport class WebRTCLib {\n\n  // private myCConfigWebRTC: ConfigWebRTC;\n\n  private myRTCPeerConnection: RTCPeerConnection;\n  private wsJmsLib: wsJmsLib\n\n  private tempRemoteDesc: RTCSessionDescriptionInit;\n  private listTempRemoteIceCandidate: RTCIceCandidate[];\n\n\tconstructor(private url: string, private channelID: string, private userID: string) {\n    \n    this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n    this.wsJmsLib = new wsJmsLib();\n\n    this.wsJmsLib.connect(url, () => {\n      this.wsJmsLib.subscribe(channelID, this.dispatchMessage);\n    });  \n  }\n\n  private dispatchMessage(message: any): void {\n    message = JSON.parse(message);\n    console.log('dispatchMessage', message);\n    switch (message.type) {\n      case 'request_web_rtc':\n        if(this.userID !== message.user_id) {\n          console.log('request_web_rtc', message);\n          this.myRTCPeerConnection.setRemoteDescription(\n            new RTCSessionDescription(this.tempRemoteDesc),\n            () => {\n              this.myRTCPeerConnection.createAnswer(\n                this.getDescription, \n                (err: Error) => console.error(err));\n          }, (err: Error) => console.error(err));\n        \n          this.tempRemoteDesc = message;\n        }\n        break;\n    \n      case 'ice_candidate_web_rtc':\n        if(this.userID !== message.user_id) {\n          console.log('ice_candidate_web_rtc', message);\n          this.listTempRemoteIceCandidate.push(message.message);\n        }\n        break;\n\n      case 'response_web_rtc':\n        if(this.userID !== message.user_id) {\n          console.log('response_web_rtc', message);\n          this.responseWebRTC(message.message);\n        }\n          \n        break;\n\n      default:\n        break;\n    }\n    \n  }\n\n  private responseWebRTC(remoteDesc: RTCSessionDescriptionInit) {\n    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n  }\n\n  private getBrowserRTCConnectionObj () {\n    let servers: RTCConfiguration = null;\n    let constraints: RTCMediaConstraints = {\n      'optional': []\n    };\n    if (window.mozRTCPeerConnection) {\n      return new mozRTCPeerConnection(servers, constraints);\n    } else if (window.webkitRTCPeerConnection) {\n        return new webkitRTCPeerConnection(servers, constraints);\n    } else {\n      return new RTCPeerConnection(servers, constraints);\n    }\n  }\n\n  private buildMessage(message: any, type: string) {\n    return {\n      chatroom_id: this.channelID,\n      user_id: this.userID,\n      type: type,\n      message: message\n    }\n  }\n\n  private sendIceCandidates(myRTCIceCandidateEvent: RTCIceCandidateEvent): void {\n    if (myRTCIceCandidateEvent.candidate) {\n      let lightRTCIceCandidateEvent = {\n        sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n        sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n        candidate: myRTCIceCandidateEvent.candidate.candidate\n      }\n      let message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n      this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n    }\n  }\n\n  private getDescription(myDesc: RTCSessionDescription) {\n    this.myRTCPeerConnection.setLocalDescription(myDesc,\n      () => {\n      this.listTempRemoteIceCandidate.forEach((remoteIceCandidate: RTCIceCandidate) => {\n        this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n      });\n\n      let message = this.buildMessage(myDesc, 'response_web_rtc');\n      this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////\n\tpublic createStream(userMediaStream: MediaStreamConstraints,\n    getLocalStream: (stream: MediaStream) => any,\n    getRemoteStream: (stream: MediaStream) => any) {\n\n    navigator.getUserMedia(userMediaStream, (myStream) => {\n\n\t\t\t\tthis.myRTCPeerConnection.addStream(myStream);\n        getLocalStream(myStream);\n\n        this.myRTCPeerConnection.onicecandidate = (myRTCIceCandidateEvent: RTCIceCandidateEvent): void => {\n          this.sendIceCandidates(myRTCIceCandidateEvent);\n        };\n\n\t\t\t\tthis.myRTCPeerConnection.onaddstream = (evt: RTCMediaStreamEvent) => {\n          getRemoteStream(evt.stream);\n        }\n\n        // This condition determine if you are the WebRTC's receiver or not\n        if(this.tempRemoteDesc) {\n        \n        } else {\n          \tthis.myRTCPeerConnection.createOffer( (myDesc: RTCSessionDescription) => {\n            \n            this.myRTCPeerConnection.setLocalDescription(myDesc);\n            let message = this.buildMessage(myDesc, 'request_web_rtc');\n            this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n          },(err: Error) => { console.error(err) });\n        }\n\t\t\n\t\t\t}, (err: Error) => console.error(err));\n\n\t}\n\n  static attachStream(mediaStream: MediaStream, HTMLElement: HTMLElement) {\n    HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/WebRTCLib.ts","/// <reference path=\"../typings/index.d.ts\" />\n/// <reference path=\"./Temasys.d.ts\" />\n\nexport {WebRTCLib} from './WebRTCLib';\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/index.ts","/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\"use strict\";\nvar wsJmsLib = (function () {\n    //////////////////////////////////////////////////////////////////////////////////\n    function wsJmsLib() {\n        this.connection = {};\n        this.session = {};\n        this.consumers = {};\n    }\n    wsJmsLib.prototype.createDestination = function (name) {\n        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n        if (name.match(reTopic)) {\n            return this.session.createTopic(name);\n        }\n        else if (name.match(reQueue)) {\n            return this.session.createQueue(name);\n        }\n        else {\n            throw new Error(\"Destination must start with /topic/ or /queue/\");\n        }\n    };\n    wsJmsLib.prototype.buildMessage = function (message) {\n        var textMessage = this.session.createTextMessage(message);\n        return textMessage;\n    };\n    //////////////////////////////////////////////////////////////////////////////////\n    wsJmsLib.prototype.connect = function (url, callback) {\n        var connectionFactory = new JmsConnectionFactory(url);\n        var that = this;\n        var connectionFuture = connectionFactory.createConnection(function () {\n            try {\n                that.connection = connectionFuture.getValue();\n            }\n            catch (err) {\n                console.error(err);\n            }\n            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            that.connection.start(function () {\n                callback();\n            });\n        });\n    };\n    ;\n    wsJmsLib.prototype.subscribe = function (channelName, messageListener) {\n        var _this = this;\n        // assuming connection has already been established and started\n        // ideally we need to maintain the state of the connection and throw error\n        // if the controller calls subscribe before connection is established\n        // or after the connection is closed\n        var topic = this.session.createTopic(channelName);\n        var consumer = this.session.createConsumer(topic);\n        this.consumers[channelName] = consumer;\n        consumer.setMessageListener(function (message) {\n            messageListener.call(_this, message.getText());\n        });\n    };\n    ;\n    wsJmsLib.prototype.send = function (message, topic, callback) {\n        var dest = this.createDestination(topic);\n        var producer = this.session.createProducer(dest);\n        var textMessage = this.buildMessage(message);\n        try {\n            var future_1 = producer.send(textMessage, function () {\n                if (future_1.exception) {\n                    console.error(future_1.exception);\n                }\n                callback();\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n        producer.close();\n    };\n    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n        var consumer = this.consumers[channelName];\n        if (consumer) {\n            delete this.consumers[channelName];\n            consumer.close(callback);\n        }\n    };\n    ;\n    wsJmsLib.baseTopicUrl = 'topic';\n    wsJmsLib.baseQueueUrl = 'queue';\n    return wsJmsLib;\n}());\nexports.wsJmsLib = wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/WsJMSLib.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar WsJMSLib_1 = require('./WsJMSLib');\nexports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}