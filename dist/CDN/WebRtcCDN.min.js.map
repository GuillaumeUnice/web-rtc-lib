{"version":3,"sources":["webpack:///WebRtcCDN.min.js","webpack:///webpack/bootstrap b563bcddb029f8743bca","webpack:///./src/WebRTCLib.ts","webpack:///./src/index.ts","webpack:///./~/ws-jms-lib-echyzen/dist/WsJMSLib.js","webpack:///./~/ws-jms-lib-echyzen/dist/index.js"],"names":["WebRtcCDN","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","ws_jms_lib_echyzen_1","WebRTCLib","url","channelID","userID","_this","this","myRTCPeerConnection","getBrowserRTCConnectionObj","wsJmsLib","connect","subscribe","dispatchMessage","prototype","message","type","user_id","tempRemoteDesc","listTempRemoteIceCandidate","push","responseWebRTC","remoteDesc","setRemoteDescription","RTCSessionDescription","servers","constraints","optional","window","mozRTCPeerConnection","webkitRTCPeerConnection","RTCPeerConnection","buildMessage","chatroom_id","sendIceCandidates","myRTCIceCandidateEvent","candidate","lightRTCIceCandidateEvent","sdpMid","sdpMLineIndex","send","JSON","stringify","getDescription","myDesc","setLocalDescription","forEach","remoteIceCandidate","addIceCandidate","RTCIceCandidate","createStream","userMediaStream","getLocalStream","getRemoteStream","navigator","getUserMedia","myStream","addStream","onicecandidate","onaddstream","evt","stream","createAnswer","err","console","error","createOffer","attachStream","mediaStream","HTMLElement","attachMediaStream","WebRTCLib_1","connection","session","consumers","createDestination","name","reTopic","RegExp","baseTopicUrl","reQueue","baseQueueUrl","match","createTopic","createQueue","Error","textMessage","createTextMessage","callback","connectionFactory","JmsConnectionFactory","that","connectionFuture","createConnection","getValue","createSession","Session","AUTO_ACKNOWLEDGE","start","channelName","messageListener","topic","consumer","createConsumer","setMessageListener","getText","dest","producer","createProducer","future","exception","e","close","unsubscribe","WsJMSLib_1"],"mappings":"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","file":"WebRtcCDN.min.js","sourcesContent":["var WebRtcCDN =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ws_jms_lib_echyzen_1 = __webpack_require__(4);\n\t// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\t// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// } , function(stream){\n\t//   // get local stream for manipulation\n\t//   let local = document.getElementById('localVideo');\n\t//   WebRTCLib.attachStream(stream, local);\n\t// });\n\t// class ConfigWebRTC {\n\t//   constructor(public url: string, public channelID: string, public userID: string) { };\n\t//   static RESPONSE = \"response_web_rtc\";\n\t//   static REQUEST = \"request_web_rtc\"; \n\t//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n\t// }\n\tvar WebRTCLib = (function () {\n\t    function WebRTCLib(url, channelID, userID) {\n\t        var _this = this;\n\t        this.url = url;\n\t        this.channelID = channelID;\n\t        this.userID = userID;\n\t        this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n\t        this.wsJmsLib = new ws_jms_lib_echyzen_1.wsJmsLib();\n\t        this.wsJmsLib.connect(url, function () {\n\t            _this.wsJmsLib.subscribe(channelID, _this.dispatchMessage);\n\t        });\n\t    }\n\t    WebRTCLib.prototype.dispatchMessage = function (message) {\n\t        switch (message.type) {\n\t            case 'request_web_rtc':\n\t                if (this.userID !== message.user_id)\n\t                    this.tempRemoteDesc = message;\n\t                break;\n\t            case 'ice_candidate_web_rtc':\n\t                if (this.userID !== message.user_id)\n\t                    this.listTempRemoteIceCandidate.push(message.message);\n\t                break;\n\t            case 'response_web_rtc':\n\t                if (this.userID !== message.user_id)\n\t                    this.responseWebRTC(message.message);\n\t                break;\n\t            default:\n\t                break;\n\t        }\n\t    };\n\t    WebRTCLib.prototype.responseWebRTC = function (remoteDesc) {\n\t        this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n\t    };\n\t    WebRTCLib.prototype.getBrowserRTCConnectionObj = function () {\n\t        var servers = null;\n\t        var constraints = {\n\t            'optional': []\n\t        };\n\t        if (window.mozRTCPeerConnection) {\n\t            return new mozRTCPeerConnection(servers, constraints);\n\t        }\n\t        else if (window.webkitRTCPeerConnection) {\n\t            return new webkitRTCPeerConnection(servers, constraints);\n\t        }\n\t        else {\n\t            return new RTCPeerConnection(servers, constraints);\n\t        }\n\t    };\n\t    WebRTCLib.prototype.buildMessage = function (message, type) {\n\t        return {\n\t            chatroom_id: this.channelID,\n\t            user_id: this.userID,\n\t            type: type,\n\t            message: message\n\t        };\n\t    };\n\t    WebRTCLib.prototype.sendIceCandidates = function (myRTCIceCandidateEvent) {\n\t        if (myRTCIceCandidateEvent.candidate) {\n\t            var lightRTCIceCandidateEvent = {\n\t                sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n\t                sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n\t                candidate: myRTCIceCandidateEvent.candidate.candidate\n\t            };\n\t            var message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n\t            this.wsJmsLib.send(JSON.stringify(message), this.channelID, function () { });\n\t        }\n\t    };\n\t    WebRTCLib.prototype.getDescription = function (myDesc) {\n\t        var _this = this;\n\t        this.myRTCPeerConnection.setLocalDescription(myDesc, function () {\n\t            _this.listTempRemoteIceCandidate.forEach(function (remoteIceCandidate) {\n\t                _this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n\t            });\n\t            var message = _this.buildMessage(myDesc, 'response_web_rtc');\n\t            _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t        });\n\t    };\n\t    ////////////////////////////////////////////////////////////////\n\t    WebRTCLib.prototype.createStream = function (userMediaStream, getLocalStream, getRemoteStream) {\n\t        var _this = this;\n\t        navigator.getUserMedia(userMediaStream, function (myStream) {\n\t            _this.myRTCPeerConnection.addStream(myStream);\n\t            getLocalStream(myStream);\n\t            _this.myRTCPeerConnection.onicecandidate = _this.sendIceCandidates;\n\t            _this.myRTCPeerConnection.onaddstream = function (evt) {\n\t                getRemoteStream(evt.stream);\n\t            };\n\t            // This condition determine if you are the WebRTC's receiver or not\n\t            if (_this.tempRemoteDesc) {\n\t                _this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(_this.tempRemoteDesc), function () {\n\t                    _this.myRTCPeerConnection.createAnswer(_this.getDescription, function (err) { return console.error(err); });\n\t                }, function (err) { return console.error(err); });\n\t            }\n\t            else {\n\t                _this.myRTCPeerConnection.createOffer(function (myDesc) {\n\t                    _this.myRTCPeerConnection.setLocalDescription(myDesc);\n\t                    var message = _this.buildMessage(myDesc, 'request_web_rtc');\n\t                    _this.wsJmsLib.send(JSON.stringify(message), _this.channelID, function () { });\n\t                }, function (err) { console.error(err); });\n\t            }\n\t        }, function (err) { return console.error(err); });\n\t    };\n\t    WebRTCLib.attachStream = function (mediaStream, HTMLElement) {\n\t        HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n\t    };\n\t    return WebRTCLib;\n\t}());\n\texports.WebRTCLib = WebRTCLib;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/// <reference path=\"../typings/index.d.ts\" />\n\t/// <reference path=\"./Temasys.d.ts\" />\n\t\"use strict\";\n\tvar WebRTCLib_1 = __webpack_require__(1);\n\texports.WebRTCLib = WebRTCLib_1.WebRTCLib;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/// <reference path=\"./wsJMSKaazing.d.ts\" />\n\tvar wsJmsLib = (function () {\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    function wsJmsLib() {\n\t        this.connection = {};\n\t        this.session = {};\n\t        this.consumers = {};\n\t    }\n\t    wsJmsLib.prototype.createDestination = function (name) {\n\t        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n\t        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n\t        if (name.match(reTopic)) {\n\t            return this.session.createTopic(name);\n\t        }\n\t        else if (name.match(reQueue)) {\n\t            return this.session.createQueue(name);\n\t        }\n\t        else {\n\t            throw new Error(\"Destination must start with /topic/ or /queue/\");\n\t        }\n\t    };\n\t    wsJmsLib.prototype.buildMessage = function (message) {\n\t        var textMessage = this.session.createTextMessage(message);\n\t        return textMessage;\n\t    };\n\t    //////////////////////////////////////////////////////////////////////////////////\n\t    wsJmsLib.prototype.connect = function (url, callback) {\n\t        var connectionFactory = new JmsConnectionFactory(url);\n\t        var that = this;\n\t        var connectionFuture = connectionFactory.createConnection(function () {\n\t            try {\n\t                that.connection = connectionFuture.getValue();\n\t            }\n\t            catch (err) {\n\t                console.error(err);\n\t            }\n\t            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\t            that.connection.start(function () {\n\t                callback();\n\t            });\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.subscribe = function (channelName, messageListener) {\n\t        var _this = this;\n\t        // assuming connection has already been established and started\n\t        // ideally we need to maintain the state of the connection and throw error\n\t        // if the controller calls subscribe before connection is established\n\t        // or after the connection is closed\n\t        var topic = this.session.createTopic(channelName);\n\t        var consumer = this.session.createConsumer(topic);\n\t        this.consumers[channelName] = consumer;\n\t        consumer.setMessageListener(function (message) {\n\t            messageListener.call(_this, message.getText());\n\t        });\n\t    };\n\t    ;\n\t    wsJmsLib.prototype.send = function (message, topic, callback) {\n\t        var dest = this.createDestination(topic);\n\t        var producer = this.session.createProducer(dest);\n\t        var textMessage = this.buildMessage(message);\n\t        try {\n\t            var future = producer.send(textMessage, function () {\n\t                if (future.exception) {\n\t                    console.error(future.exception);\n\t                }\n\t                callback();\n\t            });\n\t        }\n\t        catch (e) {\n\t            console.error(e);\n\t        }\n\t        producer.close();\n\t    };\n\t    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n\t        var consumer = this.consumers[channelName];\n\t        if (consumer) {\n\t            delete this.consumers[channelName];\n\t            consumer.close(callback);\n\t        }\n\t    };\n\t    ;\n\t    wsJmsLib.baseTopicUrl = 'topic';\n\t    wsJmsLib.baseQueueUrl = 'queue';\n\t    return wsJmsLib;\n\t})();\n\texports.wsJmsLib = wsJmsLib;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar WsJMSLib_1 = __webpack_require__(3);\n\texports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// WebRtcCDN.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b563bcddb029f8743bca","import {wsJmsLib} from 'ws-jms-lib-echyzen';\n\n// var test = new WebRTCLib('ws://yourserveraddress:8001', 'myTopic', 'userID');\n\n// test.createStream({\"video\": true, \"audio\":false}, function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// } , function(stream){\n//   // get local stream for manipulation\n//   let local = document.getElementById('localVideo');\n//   WebRTCLib.attachStream(stream, local);\n// });\n\n\n// class ConfigWebRTC {\n//   constructor(public url: string, public channelID: string, public userID: string) { };\n  \n//   static RESPONSE = \"response_web_rtc\";\n//   static REQUEST = \"request_web_rtc\"; \n//   static ICE_CANDIDATE = \"ice_candidate_web_rtc\";\n// }\n\nexport class WebRTCLib {\n\n  // private myCConfigWebRTC: ConfigWebRTC;\n\n  private myRTCPeerConnection: RTCPeerConnection;\n  private wsJmsLib: wsJmsLib\n\n  private tempRemoteDesc: RTCSessionDescriptionInit;\n  private listTempRemoteIceCandidate: RTCIceCandidate[];\n\n\tconstructor(private url: string, private channelID: string, private userID: string) {\n    \n    this.myRTCPeerConnection = this.getBrowserRTCConnectionObj();\n    this.wsJmsLib = new wsJmsLib();\n\n    this.wsJmsLib.connect(url, () => {\n      this.wsJmsLib.subscribe(channelID, this.dispatchMessage);\n    });  \n  }\n\n  private dispatchMessage(message: any): void {\n    switch (message.type) {\n      case 'request_web_rtc':\n        if(this.userID !== message.user_id)\n          this.tempRemoteDesc = message;\n        break;\n    \n      case 'ice_candidate_web_rtc':\n        if(this.userID !== message.user_id)\n          this.listTempRemoteIceCandidate.push(message.message);\n        break;\n\n      case 'response_web_rtc':\n        if(this.userID !== message.user_id)\n          this.responseWebRTC(message.message);\n        break;\n\n      default:\n        break;\n    }\n    \n  }\n\n  private responseWebRTC(remoteDesc: RTCSessionDescriptionInit) {\n    this.myRTCPeerConnection.setRemoteDescription(new RTCSessionDescription(remoteDesc));\n  }\n\n  private getBrowserRTCConnectionObj () {\n    let servers: RTCConfiguration = null;\n    let constraints: RTCMediaConstraints = {\n      'optional': []\n    };\n    if (window.mozRTCPeerConnection) {\n      return new mozRTCPeerConnection(servers, constraints);\n    } else if (window.webkitRTCPeerConnection) {\n        return new webkitRTCPeerConnection(servers, constraints);\n    } else {\n      return new RTCPeerConnection(servers, constraints);\n    }\n  }\n\n  private buildMessage(message: any, type: string) {\n    return {\n      chatroom_id: this.channelID,\n      user_id: this.userID,\n      type: type,\n      message: message\n    }\n  }\n\n  private sendIceCandidates(myRTCIceCandidateEvent: RTCIceCandidateEvent): void {\n    if (myRTCIceCandidateEvent.candidate) {\n      let lightRTCIceCandidateEvent = {\n        sdpMid: myRTCIceCandidateEvent.candidate.sdpMid,\n        sdpMLineIndex: myRTCIceCandidateEvent.candidate.sdpMLineIndex,\n        candidate: myRTCIceCandidateEvent.candidate.candidate\n      }\n      let message = this.buildMessage(lightRTCIceCandidateEvent, 'ice_candidate_web_rtc');\n      this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n    }\n  }\n\n  private getDescription(myDesc: RTCSessionDescription) {\n    this.myRTCPeerConnection.setLocalDescription(myDesc,\n      () => {\n      this.listTempRemoteIceCandidate.forEach((remoteIceCandidate: RTCIceCandidate) => {\n        this.myRTCPeerConnection.addIceCandidate(new RTCIceCandidate(remoteIceCandidate));\n      });\n\n      let message = this.buildMessage(myDesc, 'response_web_rtc');\n      this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////\n\tpublic createStream(userMediaStream: MediaStreamConstraints,\n    getLocalStream: (stream: MediaStream) => any,\n    getRemoteStream: (stream: MediaStream) => any) {\n\n    navigator.getUserMedia(userMediaStream, (myStream) => {\n\n\t\t\t\tthis.myRTCPeerConnection.addStream(myStream);\n        getLocalStream(myStream);\n\n\t\t\t\tthis.myRTCPeerConnection.onicecandidate = this.sendIceCandidates;\n\n\t\t\t\tthis.myRTCPeerConnection.onaddstream = (evt: RTCMediaStreamEvent) => {\n          getRemoteStream(evt.stream);\n        }\n\n        // This condition determine if you are the WebRTC's receiver or not\n        if(this.tempRemoteDesc) {\n          this.myRTCPeerConnection.setRemoteDescription(\n            new RTCSessionDescription(this.tempRemoteDesc),\n            () => {\n              this.myRTCPeerConnection.createAnswer(\n                this.getDescription, \n                (err: Error) => console.error(err));\n          }, (err: Error) => console.error(err));\n        } else {\n          \tthis.myRTCPeerConnection.createOffer( (myDesc: RTCSessionDescription) => {\n            \n            this.myRTCPeerConnection.setLocalDescription(myDesc);\n            let message = this.buildMessage(myDesc, 'request_web_rtc');\n            this.wsJmsLib.send(JSON.stringify(message), this.channelID, () => {});\n          },(err: Error) => { console.error(err) });\n        }\n\t\t\n\t\t\t}, (err: Error) => console.error(err));\n\n\t}\n\n  static attachStream(mediaStream: MediaStream, HTMLElement: HTMLElement) {\n    HTMLElement = attachMediaStream(HTMLElement, mediaStream);\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/WebRTCLib.ts","/// <reference path=\"../typings/index.d.ts\" />\n/// <reference path=\"./Temasys.d.ts\" />\n\nexport {WebRTCLib} from './WebRTCLib';\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/index.ts","/// <reference path=\"./wsJMSKaazing.d.ts\" />\nvar wsJmsLib = (function () {\n    //////////////////////////////////////////////////////////////////////////////////\n    function wsJmsLib() {\n        this.connection = {};\n        this.session = {};\n        this.consumers = {};\n    }\n    wsJmsLib.prototype.createDestination = function (name) {\n        var reTopic = new RegExp(wsJmsLib.baseTopicUrl, 'i');\n        var reQueue = new RegExp(wsJmsLib.baseQueueUrl, 'i');\n        if (name.match(reTopic)) {\n            return this.session.createTopic(name);\n        }\n        else if (name.match(reQueue)) {\n            return this.session.createQueue(name);\n        }\n        else {\n            throw new Error(\"Destination must start with /topic/ or /queue/\");\n        }\n    };\n    wsJmsLib.prototype.buildMessage = function (message) {\n        var textMessage = this.session.createTextMessage(message);\n        return textMessage;\n    };\n    //////////////////////////////////////////////////////////////////////////////////\n    wsJmsLib.prototype.connect = function (url, callback) {\n        var connectionFactory = new JmsConnectionFactory(url);\n        var that = this;\n        var connectionFuture = connectionFactory.createConnection(function () {\n            try {\n                that.connection = connectionFuture.getValue();\n            }\n            catch (err) {\n                console.error(err);\n            }\n            that.session = that.connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            that.connection.start(function () {\n                callback();\n            });\n        });\n    };\n    ;\n    wsJmsLib.prototype.subscribe = function (channelName, messageListener) {\n        var _this = this;\n        // assuming connection has already been established and started\n        // ideally we need to maintain the state of the connection and throw error\n        // if the controller calls subscribe before connection is established\n        // or after the connection is closed\n        var topic = this.session.createTopic(channelName);\n        var consumer = this.session.createConsumer(topic);\n        this.consumers[channelName] = consumer;\n        consumer.setMessageListener(function (message) {\n            messageListener.call(_this, message.getText());\n        });\n    };\n    ;\n    wsJmsLib.prototype.send = function (message, topic, callback) {\n        var dest = this.createDestination(topic);\n        var producer = this.session.createProducer(dest);\n        var textMessage = this.buildMessage(message);\n        try {\n            var future = producer.send(textMessage, function () {\n                if (future.exception) {\n                    console.error(future.exception);\n                }\n                callback();\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n        producer.close();\n    };\n    wsJmsLib.prototype.unsubscribe = function (channelName, callback) {\n        var consumer = this.consumers[channelName];\n        if (consumer) {\n            delete this.consumers[channelName];\n            consumer.close(callback);\n        }\n    };\n    ;\n    wsJmsLib.baseTopicUrl = 'topic';\n    wsJmsLib.baseQueueUrl = 'queue';\n    return wsJmsLib;\n})();\nexports.wsJmsLib = wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/WsJMSLib.js\n// module id = 3\n// module chunks = 0","var WsJMSLib_1 = require('./WsJMSLib');\nexports.wsJmsLib = WsJMSLib_1.wsJmsLib;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ws-jms-lib-echyzen/dist/index.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}